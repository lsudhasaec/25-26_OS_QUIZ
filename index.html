<!DOCTYPE html>
<html>
<head>
<meta charset='UTF-8'>
<title>Operating Systems MCQ Quiz</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background: linear-gradient(to right, #f9f9f9, #e0f7fa);
    padding: 20px;
    margin: 0;
  }
  .quiz-box {
    background: white;
    padding: 25px;
    border-radius: 12px;
    max-width: 800px;
    margin: auto;
    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
  }
  h2 {
    color: #00695c;
    text-align: center;
  }
  .question {
    font-weight: bold;
    margin-bottom: 15px;
    font-size: 18px;
  }
  .option {
    margin: 8px 0;
    background: #f1f8e9;
    padding: 10px;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.3s;
  }
  .option:hover {
    background: #dcedc8;
  }
  input[type="radio"] {
    margin-right: 10px;
  }
  button {
    padding: 10px 15px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
  }
  .next-btn {
    background: #00796b;
    color: white;
    margin-top: 10px;
  }
  .next-btn:disabled {
    background: #b2dfdb;
    cursor: not-allowed;
  }
  .result {
    font-size: 1.1em;
    margin-top: 15px;
    text-align: center;
  }
  .wrong {
    color: red;
  }
  .correct {
    color: green;
  }
</style>
</head>
<body>
<div class='quiz-box'>
  <h2>Operating Systems MCQ Quiz</h2>
  <div id='quiz-container'>
    <div class='question' id='question'></div>
    <div id='options'></div>
    <br>
    <button class='next-btn' id='nextBtn' onclick='nextQuestion()' disabled>Next</button>
    <div class='result' id='result'></div>
  </div>
</div>
<script>
// Question bank with Base64 encoded answers
const quizData = [
  { q: "Which of the following is not a function of an operating system?", options: ["Memory management","Process scheduling","Data encryption in hardware","I/O management"], answer: "Mg==" },
  { q: "Which type of OS executes multiple jobs by switching among them?", options: ["Batch OS","Time-sharing OS","Real-time OS","Embedded OS"], answer: "MQ==" },
  { q: "Which OS is designed to respond within strict time constraints?", options: ["Distributed OS","Real-time OS","Network OS","Batch OS"], answer: "MQ==" },
  { q: "Which of the following is a single-user, single-task operating system?", options: ["MS-DOS","UNIX","Windows 10","Linux"], answer: "MA==" },
  { q: "The part of the OS that interacts directly with hardware is called:", options: ["Kernel","Shell","Application","API"], answer: "MA==" },
  { q: "Which of these is not an example of a multitasking OS?", options: ["Windows","macOS","MS-DOS","Linux"], answer: "Mg==" },
  { q: "The OS function that keeps track of files, directories, and storage allocation is:", options: ["File management","Memory management","Process management","I/O management"], answer: "MA==" },
  { q: "Which scheduling type is used in time-sharing systems?", options: ["Preemptive","Non-preemptive","Both A and B","None"], answer: "Mg==" },
  { q: "A bootstrap program is stored in:", options: ["Hard disk","RAM","ROM","Cache"], answer: "Mg==" },
  { q: "Which of these is not a layer in the layered approach to OS design?", options: ["Hardware","Kernel","User interface","Compiler"], answer: "Mw==" },
  { q: "Which OS structure uses system calls to request services from the kernel?", options: ["Monolithic system","Microkernel","Layered system","All of the above"], answer: "Mw==" },
  { q: "Which of the following is not a mobile operating system?", options: ["Android","iOS","Symbian","MS-DOS"], answer: "Mw==" },
  { q: "The main advantage of multiprogramming is:", options: ["Higher CPU utilization","Easier debugging","Lower memory usage","Simple scheduling"], answer: "MA==" },
  { q: "In a distributed OS:", options: ["All resources are on a single machine","Multiple computers work together as a single system","All processes run on the same CPU","No need for communication"], answer: "MQ==" },
  { q: "Which of the following is a function of the command interpreter?", options: ["Load programs","Execute user commands","Manage CPU","Schedule processes"], answer: "MQ==" },
  { q: "The state of a process is defined by:", options: ["Process ID only","Program code in memory","Contents of CPU registers, program counter, and memory info","Stack only"], answer: "Mg==" },
  { q: "Which of the following is not a valid process state?", options: ["Ready","Running","Waiting","Loading"], answer: "Mw==" },
  { q: "The process control block (PCB) does not contain:", options: ["Process state","Program counter","File management info","Source code"], answer: "Mw==" },
  { q: "Which is responsible for context switching?", options: ["Dispatcher","Loader","Scheduler","Interrupt handler"], answer: "MA==" },
  { q: "The short-term scheduler selects:", options: ["Process to bring into ready queue","Process to execute next","Job to admit into system","Files to load"], answer: "MQ==" },
  { q: "Round Robin scheduling is most suitable for:", options: ["Batch processing","Time-sharing systems","Real-time systems","Single-user systems"], answer: "MQ==" },
  { q: "Which scheduling algorithm may cause starvation?", options: ["First-Come, First-Served","Shortest Job Next","Round Robin","Priority scheduling"], answer: "Mw==" },
  { q: "In preemptive scheduling:", options: ["Process cannot be interrupted","Process can be suspended","Process runs until completion","No context switching"], answer: "MQ==" },
  { q: "Which of these is not a scheduling criterion?", options: ["CPU utilization","Throughput","Response time","Page fault rate"], answer: "Mw==" },
  { q: "A zombie process is:", options: ["Waiting for I/O","Finished but still in process table","In ready queue","Orphan process"], answer: "MQ==" },
  { q: "The main advantage of multithreading is:", options: ["Lower CPU utilization","Faster context switching","Parallelism and responsiveness","Higher memory usage"], answer: "Mg==" },
  { q: "User-level threads are managed by:", options: ["OS kernel","Thread library","CPU scheduler","None"], answer: "MQ==" },
  { q: "Which is not a type of scheduler?", options: ["Long-term","Medium-term","Short-term","Ready-term"], answer: "Mw==" },
  { q: "In process creation, the parent uses:", options: ["exec()","fork()","spawn()","wait()"], answer: "MQ==" },
  { q: "Which process state transition is valid?", options: ["Ready → Waiting","Waiting → Running","Running → Ready","Ready → Running → Ready"], answer: "Mg==" },
  { q: "Which is not an IPC mechanism?", options: ["Pipes","Message queues","Semaphores","Paging"], answer: "Mw==" },
  { q: "Degree of multiprogramming is controlled by:", options: ["Short-term scheduler","Medium-term scheduler","Long-term scheduler","Dispatcher"], answer: "Mg==" },
  { q: "Which is not a benefit of process synchronization?", options: ["Data consistency","Avoid race conditions","Prevent deadlocks","Coordinate processes"], answer: "Mg==" },
  { q: "A semaphore with value 1 is called:", options: ["Binary semaphore","Counting semaphore","Mutex","Both A and C"], answer: "Mw==" },
  { q: "Critical section:", options: ["Can be executed by many processes","Requires mutual exclusion","Requires deadlock","Only in single-threaded"], answer: "MQ==" },
  { q: "Deadlock can occur when:", options: ["Resources are non-preemptive and processes are competing for them","All processes running","Only one process in system","Processes share no resources"], answer: "MA==" },
  { q: "Which is not one of the four necessary conditions for deadlock?", options: ["Mutual exclusion","Hold and wait","Circular wait","Time sharing"], answer: "Mw==" },
  { q: "Which method prevents at least one Coffman condition?", options: ["Deadlock prevention","Deadlock detection","Deadlock avoidance","Recovery"], answer: "MA==" },
  { q: "In Banker's Algorithm, a safe state means:", options: ["Deadlock occurred","Deadlock never occurs","Deadlock may occur","All processes finished"], answer: "MQ==" },
  { q: "Which is a deadlock avoidance algorithm?", options: ["FIFO","Round Robin","Banker's Algorithm","FCFS"], answer: "Mg==" },
  { q: "In a RAG, a cycle:", options: ["Always deadlock","Deadlock if single instance","Never deadlock","None"], answer: "MQ==" },
  { q: "Which is a recovery method from deadlock?", options: ["Killing processes","Preempting resources","Both A and B","None"], answer: "Mg==" },
  { q: "Which is not a characteristic of wait-die scheme?", options: ["Non-preemptive","Based on timestamps","Younger waits for older","Older waits for younger"], answer: "Mw==" },
  { q: "Which method forces processes to request all resources at once?", options: ["Hold and wait prevention","Mutual exclusion removal","Circular wait prevention","Resource ordering"], answer: "MA==" },
  { q: "Removing which condition may lower resource utilization?", options: ["Hold and wait","Mutual exclusion","Circular wait","Preemption"], answer: "MA==" },
  { q: "Deadlock detection:", options: ["Always avoids deadlock","Detects after occurrence","Removes deadlock before occurrence","Prevents circular wait"], answer: "MQ==" },
  { q: "In a system with m resources, deadlock can be avoided if:", options: ["m ≥ sum max needs","m ≥ sum allocations","m ≥ sum max needs − (n − 1)","None"], answer: "Mg==" },
  { q: "Disadvantage of deadlock prevention:", options: ["Low resource utilization","Complex implementation","Need for termination","None"], answer: "MA==" },
  { q: "Starvation differs from deadlock because:", options: ["Starvation temporary, deadlock permanent","Starvation permanent, deadlock temporary","Starvation can be avoided by aging","Deadlock can be avoided by aging"], answer: "Mg==" },
  { q: "Priority inversion relates to deadlocks:", options: ["Always causes deadlocks","Unrelated","Can cause starvation but not deadlock","Same as deadlock"], answer: "Mg==" }
];

// Shuffle questions
for (let i = quizData.length - 1; i > 0; i--) {
  const j = Math.floor(Math.random() * (i + 1));
  [quizData[i], quizData[j]] = [quizData[j], quizData[i]];
}

let currentQuestion = 0;
let score = 0;

function loadQuestion() {
  document.getElementById('result').innerHTML = '';
  let q = quizData[currentQuestion];
  document.getElementById('question').innerText = (currentQuestion+1) + '. ' + q.q;
  let optionsHtml = '';
  q.options.forEach((opt, idx) => {
    optionsHtml += "<div class='option'><label><input type='radio' name='option' value='" + idx + "' onchange='enableNext()'> " + opt + "</label></div>";
  });
  document.getElementById('options').innerHTML = optionsHtml;
  document.getElementById('nextBtn').disabled = true;
}

function enableNext() {
  document.getElementById('nextBtn').disabled = false;
}

function nextQuestion() {
  let selected = document.querySelector('input[name="option"]:checked');
  if (!selected) return;

  let answer = parseInt(selected.value);
  let correct = parseInt(atob(quizData[currentQuestion].answer));

  if (answer === correct) {
    score++;
    document.getElementById('result').innerHTML = "<span class='correct'>✅ Correct!</span>";
  } else {
    document.getElementById('result').innerHTML = "<span class='wrong'>❌ Wrong! Correct answer: " + quizData[currentQuestion].options[correct] + "</span>";
  }

  currentQuestion++;
  if (currentQuestion < quizData.length) {
    setTimeout(loadQuestion, 1500);
  } else {
    setTimeout(showFinalScore, 1500);
  }
}

function showFinalScore() {
  document.getElementById('quiz-container').innerHTML = "<h3>Quiz Completed!</h3><p>Your Score: " + score + " / " + quizData.length + "</p>";
}

loadQuestion();
</script>
</body>
</html>
